# Дженерики

Пример функции, которая получает [[Типы в TypeScript|тип]] через дженерики:

```typescript
function generic<T>(value: T): T {
	return value;
}

console.log( generic<string>('hello') );
console.log( generic<number>(15) )
```


#### Интерфейсы в дженериках
Если указать что какой-то дженерик наследует интерфейс, то свойства и методы интерфейса этого типа будут доступны в коде функции.
```typescript
interface IFoo {
	name: string
}

function generic<T extends IFoo>(value: T): void {
	if(value.name === 'GeoS'){
	}
}

console.log(generic<{name: string}>({name: 'GeoS'}))
```

Ещё пример:
```
interface IFoo<T> {
	age: T
}

const bar: IFoo<number> = {age: 10}
```

#### Вопросы
Почему используя дженерики эта конструкция вызывает ошибку?
```
function foo<T>(): T {
  return 'hello';
}
foo<string>()
```
> Ошибка: *Тип "string" не может быть назначен для типа "T".
>   Возможно создание экземпляра "T" с произвольным типом, который может быть не связан с "string"*

Понятно, что если будет передан тип `number`, то возвращать строку будет ошибкой.
Но, зато вот эта конструкция почему-то компилируется нормально:
```
async function fetchApi<T>(path: string): Promise<T> {
  const response = await fetch(`https://example.com/api${path}`);
  return response.json();
}
```
Хотя её можно вызывать вот так: `fetchApi<unknown>('path')`, не пойму как здесь вычисляется тип возвращаемого значения.

#дженерики #generics