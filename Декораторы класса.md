# Декораторы класса

[Документация](https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators)

Декоратор класса применяется для конструктора класса.

Пример:

```ts
function simpleDecorator(target: any) {
  console.log('---hi I am a decorator---')
  console.log(target)
  console.log(typeof target)
  console.log(A.constructor)
  console.log(A.prototype.constructor)
  console.log(A.constructor === target)
  console.log(A.prototype.constructor === target)
  console.log(A === target)
}

@simpleDecorator
class A {}

// Вывод в консоль
// ---hi I am a decorator---
// [class A]
// function
// [Function: Function]
// [class A]
// false
// true
// true
```

Т.е. первый аргумент [[Декораторы TypeScript|декоратора]] - это конструктор класса.

Переопределение конструктора для добавления новых свойств:

```ts
function simpleDecorator(target: any) {
  return class extends target {
    x = 5;
    constructor() {
      console.log('---decorator constructor---');
      super()
      this.y = 10;
    }
  }
}

@simpleDecorator
class A {
  constructor() {
    console.log('---hi I am a constructor---')
  }
}

console.log(new A())

// Вывод в консоль
// ---decorator constructor---
// ---hi I am a constructor---
// A { x: 5, y: 10 }

// При этом компилятор будет ругаться если обратиться к свойствам, установленным в декораторе, т.к. декоратор не изменят тип:
const a = new A();
console.log(a.x); // error...

```

Зато можно с помощью [[Декораторы TypeScript|декоратора]] переопределить методы и свойства класса:

```ts
function simpleDecorator(target: any) {
  return class extends target {
    x = 10;
    sayHi() {
      console.log('Bye');
      return 1; // изменяем возврат метода, компилятор не ругается
    }
  }
}

@simpleDecorator
class A {
  x = 5;
  sayHi() {
    console.log('Hi');
  }
}

const t = new A();
console.log(t); // A { x: 10 }
console.log(t.sayHi()); // Bye

const bla = t.sayHi(); // несмотря на то, что метод переопределён декоратором и возвращает число, автоматический вывод типа покажет тип void
```