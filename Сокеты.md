# Сокеты

> Некоторые примеры использования сокетов есть в [[Примеры комбинаций клиент-сервер]].

[Источник](https://parallel.uran.ru/book/export/html/498).

Сокет - универсальный интерфейс для создания каналов для межпроцессного взаимодействия.

Сокеты объединили в едином интерфейсе потоковую передачу данных подобную каналам _pipe_ и _FIFO_ и передачу сообщений, подобную очередям сообщений в _System V IPC_. Кроме того, сокеты добавили возможность создания клиент-серверного взаимодействия (один со многими).

Интерфейс сокетов скрывает механизм передачи данных между процессами. В качестве нижележащего транспорта могут использоваться как внутренний транспорт в ядре Unix, так и практически любые сетевые протоколы. Для достижения такой гибкости используется перегруженная функция назначения сокету имени - _bind()_. Данная функция принимает в качестве параметров идентификатор пространства имён и указатель на структуру, которая содержит имя в соответствующем формате. Это могут быть имена в файловой системе Unix, IP адрес + порт в TCP/UDP, MAC-адрес сетевой карты в протоколе IPX.

## Классификация сокетов

_Stream_

Поток байтов без разделения на записи, подобный чтению-записи в файл или каналам в _Unix_. Процесс, читающий из сокета, не знает, какими порциями производилась запись в сокет пишущим процессом. Данные никогда не теряются и не перемешиваются.

- Непрерывный поток байтов
- Упорядоченный приём данных
- Надёжная доставка данных

_Datagram_

Передача записей ограниченной длины. Записи на уровне интерфейса сокетов никак не связанны между собой. Отправка записей описывается фразой: "отправил и забыл". Принимающий процесс получает записи по отдельности в непредсказуемом порядке или не получает вовсе.

- Деление потока данных на отдельные записи
- Неупорядоченный приём записей
- Возможна потеря записей

_Sequential packets_

Надёжная упорядоченная передача с делением на записи. Использовался в _Sequence Packet Protocol_ для _Xerox Network Systems_. Не реализован в _TCP/IP_, но может быть имитирован в _TCP_ через [Urgent Pointer](http://urchin.earth.li/~twic/Sequenced_Packets_Over_Ordinary_TCP.html).

- Деление потока данных на отдельные записи
- Упорядоченная передача данных
- Надёжная доставка данных

_Raw_

Данный тип сокетов предназначен для управление нижележащим сетевым драйвером. В _Unix_ требует администраторских полномочий. Примером использования _Raw_-сокета является программа `ping`, которая отправляет и принимает управляющие пакеты управления сетью - _ICMP_. Файл _/usr/bin/ping_ в старых версиях _Linux_ имел флаг смены полномочий _suid_, а в новых версиях - флаги дополнительных полномочий - _cap_net_admin_ и _cap_net_raw_.

## Имена сокетов

Имена сокетов на сервере назначаются вызовом _bind()_, а на клиенте, как правило, генерируются ядром.

- Inet - сокеты именуются с помощью IP адресов и номеров портов
- Unix - сокетам даются имена объектов типа _socket_ в файловой системе
- IPX - имена на основе MAC-адресов сетевых карт
- ... - возможны и другие варианты

## TCP/IP

Для передачи данных с помощью семействе протоколов _TCP/IP_ реализованы два вида сокетов _Stream_ и _Datagram_. Все остальные манипуляции с сетью _TCP/IP_ осуществляются через _Raw_-сокеты.

- TCP = Stream
- UDP = Datagram
- ICMP = RAW
- Sequential packets - были экспериментальные реализации в 1990-х, которые не вышли за рамки научных исследований

# API Сокетов

## Создание сокета

```
#include <sys/types.h>
#include <sys/socket.h>

int s = socket(int domain, int type, int protocol);
```

_domain_ - семейство протоколов, которое будет использоваться для передачи данных. Имена макросов, задающих домен, начинаются с _PF_ - _protocol family_/

- PF_UNIX - внутреннее межпроцессное взаимодействие
- PF_INET - стек TCP/IP

_type_ - тип сокета

- SOCK_DGRAM - ненадежная передача данных с сохранением границ сообщений (соответствует протоколу UDP),
- SOCK_STREAM - надежная передача данных без сохранения границ сообщений (соответствует протоколу TCP),
- SOCK_SEQ - надежная передача данных с сохранением границ сообщений (в стеке TCP/IP не поддерживается),
- SOCK_RAW - низкоуровневый доступ к протоколу (уровень IP, ICMP).

_protocol_ Поскольку в семействе протоколов _TCP/IP_ протокол однозначно связан с типом сокета, а в домене _Unix_ понятие протокола вообще отсутствует, то этот параметр всегда равен нулю, что соответствует автовыбору.

В домене _Unix_ возможно создание пары соединённых между собой безымянных сокетов, которые буду вести себя подобно неименованному каналу _pipe_. В отличие от неименованных каналов, оба сокета открыты и на чтение и на запись.

```
int result;
int sockfd[2];
result=socketpair(AF_UNIX, SOCK_STREAM, 0, sockfd);
```

## Назначение имени

Для того, чтобы клиенты могли подключаться к серверу, сервер должен иметь заранее известное имя. Вызов _bind()_ обеспечивает назначение имени серверному сокету. Сервер получит имя клиентского сокета в момент соединения (stream) или получения сообщения (datagram), поэтому на клиентской стороне имя сокету, как правило, назначается ядром ОС, хотя и явное присвоение с помощью _bind()_ остаётся доступным.

```
#include <sys/types.h>
#include <sys/socket.h>

int bind(int sockfd, struct sockaddr *localaddr, int addrlen);
```

Второй параметр функции _bind()_ - адрес - формально описан как указатель на структуру _sockaddr_ с удобным размером 16 байт. _sockaddr_ можно рассматривать как суперкласс (без методов) от которого наследуются реально используемые классы _sockaddr_un_, _sockaddr_in_ и т.д. Все они наследуют поле _sa_family_ - тип адреса, благодаря которому _bind()_ корректно интерпретирует переданную ему структуру данных. Для того, чтобы избежать предупреждений компилятора, рекомендуется явно преобразовывать тип второго параметра к _struct sockaddr *_.

Макросы, которые присваиваются полю _sa_family_ по своему числовому значению совпадают с соответствующими макросами определяющими семейство протоколов, но начинаются с _AF_ - _address family_.

```
struct sockaddr {
  u_short   sa_family;
  char      sa_data[14];
};
```

Имя в домене _Unix_ - строка с именем сокета в файловой системе.

```
struct sockaddr_un {
  short sun_family; /* AF_UNIX */
  char  sun_path[108];
};
```

Имя в домене _Internet_ - _IP_-адрес и номер порта, которые хранятся в виде целых числе в формате _BIG ENDIAN_. Для заполнения структуры они должны быть преобразованы из локального представления в сетевое функциями _htonl()_ и _htons()_ для длинных и коротких целых соответственно. Упаковка _IP_-адреса в дополнительную структуру связана, скорее всего, с какими-то историческими причинами.

```
struct sockaddr_in {
  short         sin_family; /* AF_INET */
  u_short       sin_port;       /* Port Number */
  struct in_addr    sin_addr;/* Internet address */
  char          sin_zero[8];    /*Not used*/
}

struct in_addr {
  unsigned long int s_addr;
}
```

## Соединение с сервером (в основном _Stream_)

Для сокета типа _Stream_ вызов _connect()_ соединяет сокет клиента с сокетом сервера, создавая поток передачи данных. Адрес сервера _servaddr_ заполняется по тем же правилам, что и адрес, передаваемый в _bind()_.

Для сокета типа _Datagram_ вызов _connect()_ запоминает адрес получателя, для отправки сообщений вызовом _send()_. Можно пропустить этот вызов и отправлять сообщения вызовом _sendto()_, явно указывая адрес получателя для каждого сообщения.

```
#include <sys/types.h>
#include <sys/socket.h>

int connect(int sockfd, struct sockaddr *servaddr, int addrlen);
```

## Прослушивание сокетов сервером (только _Stream_)

Вызов _listen()_ на стороне сервера превращает сокет в фабрику сокетов, которая будет с помощью вызова _accept()_ возвращать новый транспортный сокет на каждый вызов _connect()_ со стороны клиентов.

```
#include <sys/types.h>
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```

_backlog_ - количество запросов клиентов _connect()_, которые будут храниться в очереди ожидания, пока сервер не вызовет _accept()_.

Обработка запроса клиента.

Клиентский _connect()_ будет заблокирован до тех пор, пока сервер не вызовет _accept()_. _accept()_ возвращает транспортный сокет, который связан с сокетом для которого клиент вызвал _connect()_. Этот сокет используется как файловый дескриптор для вызовов _read()_, _write()_, _send()_ и _recv()_.

В переменную _clntaddr_ заносится адрес подключившегося клиента.

```
#include <sys/types.h>
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *clntaddr, int *addrlen);
```

## Чтение/запись данных

Для операций чтения-записи данных через сокеты могут применяться стандартные вызовы _read()_ и _write()_, однако существуют и более специализированные вызовы:

```
#include <sys/types.h>
#include <sys/socket.h>

ssize_t write(int fildes, const void *buf, size_t nbyte);
ssize_t send(int sockfd, const char *msg, int len, int flags);
ssize_t sendto(int sockfd, const char *msg, int len, int flags,const struct sockaddr *toaddr, int tolen) ;
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

ssize_t read(int fildes, const void *buf, size_t nbyte);
ssize_t recv(int sockfd, char *buf, int len, int flags);
ssize_t recvfrom(int sockfd, char *buf, int len, int flags, struct sockaddr *fromaddr, int *fromlen);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```

Все вызовы применимы и к потоковым сокетам и к сокетам датаграмм. При попытке прочитать датаграмму в слишком маленький буфер, её хвост будет утерян.

_write(fd,buf,size)_ == _send(fd,buf,size,0)_ == _sendto(fd,buf,size,0,NULL,0)_

_send()_ может применяться только к тем сокетам, для которых выполнен _connect()_.

При использовании _sendto()_ с потоковым сокетом адрес _toaddr_ игнорируется если был выполнен _connect()_. Если же _connect()_ не был выполнен - в _errno_ возвращается ошибка _ENOTCONN_.

_sendmsg()_ и _recvmsg()_ близки к вызовам _writev()_ и _readv()_, поскольку позволяют одним вызовом отправить/принять несколько буферов данных.

Флаги _send()_:

- _MSG_DONTWAIT_ - неблокирующая отправка. В случае невозможности отправить порцию данных возвращается -1, а переменная _errno_ выставляется в _EAGAIN_.
- _MSG_OOB_ - отправка внеочередных данных (_out-of-band_) если они поддерживаются протоколом

Флаги _recv()_:

- _MSG_DONTWAIT_ - неблокирующее чтение
- _MSG_OOB_ - приём внеочередных данных
- _MSG_PEEK_ - "подглядывание" - чтение данных без удаления их из канала

## Управление окончанием соединения (в основном _Stream_)

Вызов _close()_ закрывает сокет и освобождает все связанные с ним структуры данных.

Для контроля над закрытием потоковых сокетов используется вызов _shutdown()_, который позволяет управлять окончанием соединения.

int shutdown () (int sock, int cntl);

Аргумент cntl может принимать следующие значения:

- 0: больше нельзя получать данные из сокета;
- 1: больше нельзя посылать данные в сокет;
- 2: больше нельзя ни посылать, ни принимать данные через этот сокет.

# Асинхронные операции - select

Для реализации клиент-серверной архитектуры на основе сокетов необходимо предоставить разработчику сервера инструмент для параллельной работы с несколькими клиентами. Возможные варианты:

- создание нового процесса для каждого клиента. Плохо масштабируется, поскольку требует дополнительных ресурсов на создание и последующее планирование процессов. Нити масштабируются лучше, но в ранних реализациях _Unix_ они отсутствовали.
- вызов _callback_ов при поступлении данных от пользователя - в _Unix_ не реализовано
- бесконечный цикл с попытками неблокирующего чтения-записи. Занимает процессорное время.
- блокирующая операция, ожидающая появления сокетов, доступных для чтения-записи.

Последний вариант является наиболее часто используемым в _Unix_ и реализуется вызовами _select()_ и _poll()_.

Вызовы отличаются по формату параметров, но эквивалентны по своему назначению. Они приостанавливают выполнение процесса, до появления данных от клиента, появления возможности отправить данные клиенту, появления ошибки приёма-передачи или до истечения таймаута. Если точнее, то для операций чтения-записи проверяется, что они не будут заблокированы.

Реализация этих вызовов позволяет использовать их для отслеживания состояния любых файловых дескрипторов, а не только сокетов.

## SELECT

Вызов _select()_ получает три битовых набора флагов (чтение, запись, ошибка) размером с максимальное доступное число открытых файловых дескрипторов. Флаг в какой-то позиции означает что мы наблюдаем за соответствующим файловым дескриптором.

Параметр _nfds_ задает номер максимального выставленного флага и служит для оптимизации.

```
#include <sys/select.h>
int select(int nfds,
   fd_set *readfds,
   fd_set *writefds,
   fd_set *exceptfds,
   struct timeval *timeout);
```

Для манипуляции флагами используется следующие функции, которые позволяют очистить набор флагов, установить флаг, сбросить флаг, проверить состояние флага:

```
void FD_ZERO(fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
```

При изменении состояния каких-либо интересующего нас файловых дескрипторов _select()_ сбрасывает все флаги и выставляет те, которые обозначают, какие события и на каких файловых дескрипторах произошли. Возвращается значение, указывающее сколько флагов возвращено. Если событий не было и возврат из _select()_ произошёл по таймауту, все наборы флагов обнуляются и возвращается ноль.

В случае ошибки возвращается -1. Значение флагов не определено.

Таймаут задаётся структурой _timeval_, содержащей секунды и микросекунды

```
struct timeval { 
    long    tv_sec;         /* seconds */
    long    tv_usec;        /* microseconds */
};
```

Поскольку вызов _sleep()_ работает с точностью до секунды, то для приостановки процесса на более короткие промежутки времени часто используют _select()_ с указателями _NULL_ вместо указателей на флаги.

## POLL

Вызов _poll()_ функционально эквивалентен _select_. Его параметры как бы "вывернуты наизнанку" по сравнению с _select()_. Вместо трёх наборов битовых файлов в _poll()_ массив интересующих файловых дескрипторов размером _nfds_. С каждым файловым дескриптором связаны две переменные: флаги интересующих событий и флаги случившихся событий. Время таймаута задаётся в миллисекундах.

```
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

Структура _pollfd_

struct pollfd { int fd; /* file descriptor _/ short events; /_ requested events _/ short revents; /_ returned events */ };

Битовые флаги в _events_ определяются макросами:

```
#define POLLIN      0x0001    /* Можно считывать данные */
#define POLLPRI     0x0002    /* Есть срочные данные */
#define POLLOUT     0x0004    /* Запись не будет блокирована */
#define POLLERR     0x0008    /* Произошла ошибка */
#define POLLHUP     0x0010    /* Обрыв связи */
#define POLLNVAL    0x0020    /* Неверный запрос: fd не открыт */
```

# Диаграмма взаимодействия сокетов datagram

Ниже представлена временная диаграмма соединения клиента и сервера через сокет типа _Datagram_

|Сервер||Клиент|
|---|---|---|
|Создание сокета socket()||Создание сокета socket()|
|Присвоение имени bind()|||
|Начало цикла работы с клиентами|||
|Прием сообщения с адресом отправителя recvfrom()|<=|Отправка сообщения по адресу sendto()|
|Извлечение адреса клиента из ответа recvfrom()|||
|Отправка сообщения по адресу sendto()|=>|Приём сообщения recv()|
|||Закрытие сокета close()|
|Конец цикла работы с клиентами|||
|Закрытие сокета close()|||

# Диаграмма взаимодействия сокетов stream

Ниже представлена временная диаграмма соединения клиента и сервера через сокет типа _Stream_

|Сервер||Клиент|
|---|---|---|
|Создание сокета socket()||Создание сокета socket()|
|Присвоение имени bind()|||
|Создание очереди запросов listen()|||
|Начало цикла работы с клиентами|||
|Выбор соединения из очереди accept()|<=|Установка соединения connect()|
|read()|<=|write()|
|write()|=>|read()|
|Закрытие транспортного сокета close()||Закрытие сокета close()|
|Конец цикла работы с клиентами|

#сокет