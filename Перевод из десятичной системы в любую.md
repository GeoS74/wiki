
# Перевод из десятичной системы в любую


На самом деле не в любую, а в систему по основанию от 2 до 36. Потому что 26 букв + 10 цифр вместе будет 36.

Псевдокод:

```
ЦИКЛ
	цифра = число % основание
	записать цифру
	число = число / основание
ПОКА число > 0
```

> Этот алгоритм запишет строку в перевёрнутом виде, поэтому в конце надо обязательно её "развернуть".

Пример для перевода 4 в двоичную систему:

1) 4 % 2 = 0 (записали 0)
2) 4 / 2 = 2 (это следующее число)
3) 2 % 2 = 0 (записали 0)
4) 2 / 2 = 1 (это следующее число)
5) 1 % 2 = 1 (записали 1)
6) 1 / 2 = 0 (выходим из цикла)

В результате записано "001", переворачиваем строку и получаем "100".

Есть другой вариант алгоритма, который не требует переворачивания строки, но он сложнее. Псевдокод:

```
НАЙТИ старшую степень основания ≤ |число|
    степень = 1
    ПОКА степень * основание ≤ |число|:
        степень = степень * основание
ПОКА степень > 0:
    цифра = |число| / степень      // целочисленное деление
    записать символ цифры в массив
    |число| = |число| - цифра * степень
    степень = степень / основание
ЕСЛИ исходное число < 0:
    добавить знак '-' в начало строки
```

Минусы:
1) поиск старшей степени основания использует либо дополнительный цикл (как в псевдокоде) либо логарифм (требует подключения math.c);
2) логарифмы могут давать погрешности в вычислениях;
3) т.к. подключается библиотека math.c то компиляция будет с флагом `-lm`;
4) В классическом алгоритме мы только делим число на основание. Здесь мы ещё и делим степень на основание, и умножаем цифру на степень;
5) Сложнее реализовать для чисел, которые точно равны степени.